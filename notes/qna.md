# Example ELID-Style Full-Stack Test Question

### Question Title: Mini Device Management System (Lite)

...Question Details
● Create devices
● Activate devices (spawning per-device subprocesses)
● Simulate transactions generated by these active devices
	transaction entry or exit. timestamp
● Persist transactions directly into a SQL database
---

## 1. Problem Understanding & Restatement

**Q: Can you explain how you understand the problem?**

**Template Answer:**

### [System Name Type]

The task is to build a web-based system that enables researchers to:
- **[Features with simple description]** ...description

> additional you want to add for the prompt

## 2. Scope Clarification & Assumptions

**Q: What assumptions are you making?**

**Template Answer:**

**Key Assumptions:**

- No real-time collaboration needed for MVP


## 3. Functional Requirements Breakdown

**Q: What are the main functional requirements?**

**Template Answer:**

**MVP Functional Requirements:**

1. **[Main Features]**
	 - feature list

2. **[Secondary Features]**
	 - feature list

## 4. Non-Functional Requirements (NFRs)

**Q: What non-functional requirements are you considering?**

**Template Answer:**

**Key Non-Functional Requirements:**

- **Performance**: API responses should return in <500ms for typical queries
- **Usability**: Intuitive interface requiring minimal training
- **Reliability**: Data persistence - no loss of experiment records
- **Scalability**: Handle ~100 experiments and ~1000 runs without performance issues
- **Maintainability**: Clean, simple code structure for future enhancements
- **Availability**: Should work reliably during normal research hours (not 24/7 required)
- **Browser Compatibility**: Works on modern browsers (Chrome, Firefox, Safari, Edge)


## 5. High-Level Architecture

**Q: What architecture would you propose?**

**Template Answer:**

**Three-Tier Architecture:**

```
┌─────────────────────────────────────┐
│     Frontend (Vite React)           │
│  • ...pages                         │
└──────────────┬──────────────────────┘
               │ HTTP/REST
┌──────────────▼──────────────────────┐
│  Backend API (Bun/Express)  				│
│  • REST endpoints                   │
│  • Business logic                   │
│  • Data validation                  │
└──────────────┬──────────────────────┘
               │ Prisma ORM
┌──────────────▼──────────────────────┐
│  Database (PostgreSQL(docker))      │
│  • Tables & relationships          	│
└─────────────────────────────────────┘
```

**Key Components:**
- **Frontend**: Single-page app with forms and chart visualization
- **Backend**: RESTful API handling all business logic
- **Database**: Relational database for structured experiment data



## 6. Data Model & Storage

**Q: How would you design the data model?**

**Template Answer:**

**Database Schema:**

```
[model name] Table:
├── id (Primary Key, UUID)
... main info
├── created_at (Timestamp)
└── updated_at (Timestamp)

[second model name] Table:
├── id (Primary Key, UUID)
├── [model id] (Foreign Key → model.id)
... additional info
├── executed_at (Timestamp)
└── created_at (Timestamp)
```

**Design Decisions:**
- Use JSON for parameters to handle flexible experiment types
- Store result as single numeric value (simplicity for MVP)
- Include timestamps for trend analysis
- Foreign key ensures data integrity between experiments and runs



## 7. API Design Approach

**Q: How do you design your APIs?**

**Template Answer:**

**RESTful API Endpoints (MVP):**

```
[model name]:
├── GET    /api/[model name]           → List all 
├── POST   /api/[model name]           → Create new 
├── GET    /api/[model name]/:id       → Get details
└── DELETE /api/[model name]/:id       → Delete 

```

**API Response Format:**
```json
{
  "success": true,
  "data": { /* actual data */ },
  "error": null
}
```

**Design Principles:**
- RESTful conventions for predictability
- Consistent response format
- Meaningful HTTP status codes
- Input validation on all endpoints



## 8. Edge Cases & Failure Handling

**Q: What edge cases did you consider?**

**Template Answer:**

**Edge Cases & Handling:**

1. **Empty/Missing Data**


2. **Invalid Input**


3. **Concurrent Operations**


4. **Data Integrity**


5. **Statistics Edge Cases**


**Error Responses:**
- Return meaningful HTTP status codes (400, 404, 500)
- Include user-friendly error messages



## 9. Trade-offs & Design Decisions

**Q: What trade-offs did you make?**

**Template Answer:**

**Key Trade-offs:**



## 10. Testing Strategy

**Q: How would you test this system?**

**Template Answer:**

**Testing Approach (MVP):**

1. **Backend API Tests**
   - Unit tests for business logic (statistics calculations)
   - Integration tests for all API endpoints
   - Test CRUD operations on experiments and runs
   - Test edge cases (empty data, invalid inputs)
   - Example: Verify average calculation with multiple runs

2. **Frontend Tests**
   - Unit tests for form validation
   - Component tests for chart rendering
   - User interaction tests (create, delete operations)

3. **Database Tests**
   - Test data relationships (foreign keys work correctly)
   - Test cascade delete (deleting experiment removes runs)
   - Verify data persistence after operations

4. **Manual Testing**
   - End-to-end workflows (create experiment → add runs → view stats)
   - UI usability with realistic data
   - Browser compatibility

**Test Coverage Target:** 70% for MVP

**Tools:**
- Backend: Jest, Supertest, or pytest
- Frontend: React Testing Library, Jest
- DB: Direct SQL queries to verify data



## 11. Extensibility & Future Improvements

**Q: If you had more time, what would you improve?**

**Template Answer:**

**Future Enhancements (Post-MVP):**


## 12. Closing Confidence Statement

**Q: Are you comfortable with this approach?**

**Template Answer:**

**Confidence & Rationale:**


**Readiness:** Ready to proceed with implementation in phases (database → API → Frontend)

