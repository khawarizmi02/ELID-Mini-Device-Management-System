### **OVERVIEW**

**Title:** Mini Device Management System (Lite)  
**Duration:** 2 hours  
**Allowed Tools:** Internet, ChatGPT / Copilot / any coding AI, documentation, public packages.  
**Not allowed**: Use of paid external services requiring credentials. Local resources (Docker Hub public images) are allowed.

**Challenge Overview**   
Build a mini device management prototype composed of dockerized services.  
The system should allow a user to:

* Create devices  
* Activate devices (spawning per-device subprocesses)  
* Simulate transactions generated by these active devices  
* Persist transactions directly into a SQL database 

**Deliverables (what to submit)**

1. Source code for all services (UI, Backend).  
2. Dockerfile for each service and a top-level docker-compose.yml that starts:  
   1. Database (Postgres)  
   2. Backend service  
   3. UI service  
3. README.md with:  
   1. Short run instructions (how to start with docker-compose up)  
   2. Any credentials (DB user/pass, API token)  
   3. Short design notes (3–6 sentences about architecture decisions)

**Submission format:** Git repo (zip or link). Include everything so reviewers can run docker-compose up and test.

**Skills tested:** Frontend, Backend, Database, REST API design, Docker, Docker Compose, Git, Concurrency & Threading, System Design Fundamentals

### **DETAILS**

**Services (must be separate containers)**

Your solution must consist of three essential services:

1. UI Service  
   * Framework of your choice (React)

2. Backend Service  
   * Go preferred, but Python or Node.js also acceptable

3. Database Service  
   * PostgreSQL

All services should be containerized and managed through Docker Compose.

**Functional Requirements**

1. Device Management (UI \+ Backend \+ Database)

From the UI, the user should be able to:

1. Create Device  
   1. Device types:  
      1. Access Controller  
         2. Face Recognition Reader  
         3. ANPR  
      2. Each device stored in DB must include at minimum:  
* id (UUID or auto-increment)  
* name (string)  
* device\_type (enum/string) — one of: access\_controller, face\_reader, anpr  
* ip\_address (string)  
* status (string) — inactive or active  
* created\_at, updated\_at (timestamps)

  You may include extra fields specific to device type.

  2. List Devices  
     1. Show all devices from the database.  
     2. Display status as Inactive initially.

  3. Activate Device  
     1. When the user clicks Activate, the backend should:  
        1. Spin up a sub-process (e.g., Go routine / Python thread) for that device.  
        2. The presence of the sub-process indicates the device is active.  
     2. Each active sub-process must:  
        1. Simulate transaction creation at random intervals.  
        2. Transactions generated by device sub-processes must include  
* transaction\_id (UUID or unique)  
* device\_id (foreign key)  
* timestamp (ISO datetime)  
* username (string) — generated randomly or from a small list  
* message or event\_type (string) — e.g., access\_granted, face\_match, plate\_read  
* any extra metadata (optional)  
  3. Write each transaction direction into the database (transactions table)  
       
2. Transaction Handling (Backend \+ Database)  
   1. The Backend service is responsible for:  
      1. Managing all device subprocesses  
      2. Writing transactions directly into the database  
   2. Each subprocess should safely write to the shared database connection. Implement proper synchronization (mutex/locking or connection pooling) to avoid conflicts  
   3. Sample DB schema for transactions (candidate may adapt)  
      CREATE TABLE transactions (  
        transaction\_id UUID PRIMARY KEY DEFAULT gen\_random\_uuid(),  
        device\_id UUID REFERENCES devices(id),  
        username TEXT,  
        event\_type TEXT,  
        timestamp TIMESTAMP,  
        payload JSONB,  
        created\_at TIMESTAMP DEFAULT now()  
      );  
        
3. UI Interface  
   1. Display the list of devices and their statuses (Active/Inactive).  
   2. Provide buttons to:  
      1. Add new devices.  
      2. Activate existing devices.  
      3. View all transactions (fetched from the database via backend API).

**Dockerization**

* Each service (UI, Backend) must have its own Dockerfile.  
* Use docker-compose.yml to orchestrate:  
  * All containers  
  * Proper network connectivity between services  
  * Required environment variables (ports, DB credentials, etc.)  
* Running:  
  * “docker-compose up” should start the entire system.

### **EVALUATION CRITERIA**

Your submission will be assessed on the following areas:

**1\. Backend**

* REST APIs for creating and activating devices, fetching transactions  
* Safe concurrent writes to DB  
* Proper error handling

**2\. Database**

* Devices and transactions tables with correct relationships  
* Data persists correctly

**3\. UI**

* List devices with status  
* Add new devices  
* Activate devices  
* View transactions

**4\. Functional Workflow**

* Full flow works: Create → Activate → Generate → Persist → View  
* Multiple devices can run concurrently

**5\. Docker**

* Each service containerized  
* `docker-compose up` starts the full system  
* Services communicate correctly

**6\. Code Quality & Documentation**

* Clean, readable, modular code  
* README with run instructions, credentials, and short design notes

