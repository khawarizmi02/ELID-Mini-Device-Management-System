OVERVIEW

Title: Mini Device Management System (Lite)
Duration: 2 hours
Allowed Tools: Internet, ChatGPT / Copilot / any coding AI, documentation, public packages.
Not allowed: Use of paid external services requiring credentials. Local resources (Docker Hub public images) are allowed.

Challenge Overview 
Build a mini device management prototype composed of dockerized services.
The system should allow a user to:
Create devices
Activate devices (spawning per-device subprocesses)
Simulate transactions generated by these active devices
Persist transactions directly into a SQL database 

Deliverables (what to submit)

Source code for all services (UI, Backend).
Dockerfile for each service and a top-level docker-compose.yml that starts:
Database (Postgres or MySQL)
Backend service
UI service
README.md with:
Short run instructions (how to start with docker-compose up)
Any credentials (DB user/pass, API token)
Short design notes (3–6 sentences about architecture decisions)

Submission format: Git repo (zip or link). Include everything so reviewers can run docker-compose up and test.

Skills tested: Frontend, Backend, Database, REST API design, Docker, Docker Compose, Git, Concurrency & Threading, System Design Fundamentals






DETAILS
Services (must be separate containers)
Your solution must consist of three essential services:
UI Service
Framework of your choice (React, Angular, Vue, etc.)


Backend Service
Go preferred, but Python or Node.js also acceptable


Database Service
PostgreSQL or MySQL
All services should be containerized and managed through Docker Compose.
Functional Requirements
Device Management (UI + Backend + Database)
From the UI, the user should be able to:
Create Device
Device types:
Access Controller
Face Recognition Reader
ANPR
Each device stored in DB must include at minimum:
id (UUID or auto-increment)
name (string)
device_type (enum/string) — one of: access_controller, face_reader, anpr
ip_address (string)
status (string) — inactive or active
created_at, updated_at (timestamps)
You may include extra fields specific to device type.

List Devices
Show all devices from the database.
Display status as Inactive initially.

Activate Device
When the user clicks Activate, the backend should:
Spin up a sub-process (e.g., Go routine / Python thread) for that device.
The presence of the sub-process indicates the device is active.
Each active sub-process must:
Simulate transaction creation at random intervals.
Transactions generated by device sub-processes must include
transaction_id (UUID or unique)
device_id (foreign key)
timestamp (ISO datetime)
username (string) — generated randomly or from a small list
message or event_type (string) — e.g., access_granted, face_match, plate_read
any extra metadata (optional)
Write each transaction direction into the database (transactions table)

Transaction Handling (Backend + Database)
The Backend service is responsible for:
Managing all device subprocesses
Writing transactions directly into the database
Each subprocess should safely write to the shared database connection. Implement proper synchronization (mutex/locking or connection pooling) to avoid conflicts
Sample DB schema for transactions (candidate may adapt)
CREATE TABLE transactions (
  transaction_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  device_id UUID REFERENCES devices(id),
  username TEXT,
  event_type TEXT,
  timestamp TIMESTAMP,
  payload JSONB,
  created_at TIMESTAMP DEFAULT now()
);

UI Interface
Display the list of devices and their statuses (Active/Inactive).
Provide buttons to:
Add new devices.
Activate existing devices.
View all transactions (fetched from the database via backend API).

Dockerization
Each service (UI, Backend) must have its own Dockerfile.
Use docker-compose.yml to orchestrate:
All containers
Proper network connectivity between services
Required environment variables (ports, DB credentials, etc.)
Running:
“docker-compose up” should start the entire system.
